package com.chbank.t24;
import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.StringReader;import java.io.StringWriter;import java.io.Writer;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.Date;import java.util.Map.Entry;
import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.transform.OutputKeys;import javax.xml.transform.Result;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerConfigurationException;import javax.xml.transform.TransformerException;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMResult;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import javax.xml.transform.stream.StreamSource;
import java.util.TreeMap;import java.util.concurrent.ArrayBlockingQueue;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;import org.springframework.core.io.FileSystemResource;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.InputSource;import org.xml.sax.SAXException;
import com.chbank.t24.bean.DataPatchConfig;
import oracle.ucp.jdbc.PoolDataSource;import oracle.ucp.jdbc.PoolDataSourceFactory;
public class DataPatch {
 static final boolean CONNECTION_POOL = true;
 static int NUM_THREAD = 10; static int NOT_START = -1; static int RUNNING = 1; static int STOPPED = 0; static Document NO_MORE_WORK;
 private String driver; private String url; private String username; private String password;
 private FileWriter writer = null;
 private ArrayBlockingQueue<Document> queue;
 private DataPatchConsumer[] consumers; private DataPatchProducer producer; private DataPatchConfig config;
 private PoolDataSource pds = null;
 public DataPatch(String driver, String url, String username, String password, String thread_num) {  super();  this.driver = driver;  this.url = url;  this.username = username;  this.password = password;  if (thread_num != null) {   int t = Integer.parseInt(thread_num);   DataPatch.NUM_THREAD = t;  }  this.queue = new ArrayBlockingQueue<Document>(NUM_THREAD * 1000); }
 public Writer getWriter() {  return this.writer; }
 public Connection getConnection() throws SQLException {  if (CONNECTION_POOL) {   if (pds == null) {    pds = PoolDataSourceFactory.getPoolDataSource();    pds.setConnectionFactoryClassName("oracle.jdbc.pool.OracleDataSource");    pds.setURL(this.url);    pds.setUser(this.username);    pds.setPassword(this.password);    pds.setInitialPoolSize(1);   }   return (pds.getConnection());  } else {   return (DriverManager.getConnection(this.url, this.username, this.password));  } }
 public ArrayBlockingQueue<Document> getQueue() {  return queue; }
 public void initialize(DataPatchConfig config) {  this.config = config;  try {   if (this.config.getTargetType() == DataPatchConfig.TABLE     || this.config.getSourceType() == DataPatchConfig.SQL) {    if (!CONNECTION_POOL)     Class.forName(this.driver);   }   if (this.config.getTargetType() == DataPatchConfig.FILE) {    File f = new File(this.config.getTarget());    this.writer = new FileWriter(f);   }   DocumentBuilderFactory fctr = DocumentBuilderFactory.newInstance();   DocumentBuilder bldr = fctr.newDocumentBuilder();   InputSource insrc = new InputSource(new StringReader("<no_more_work/>"));   NO_MORE_WORK = bldr.parse(insrc);
  } catch (ParserConfigurationException | SAXException | IOException | ClassNotFoundException e) {   e.printStackTrace();  }
  this.consumers = new DataPatchConsumer[NUM_THREAD]; }
 public void process() {  config.getSource();  this.producer = new DataPatchProducer(this, this.config);  Thread tp = new Thread(this.producer);  tp.setName("Producer");  tp.setPriority(Thread.MAX_PRIORITY);  tp.start();  for (int i = 0; i < NUM_THREAD; i++) {   this.consumers[i] = new DataPatchConsumer(this, this.config);   Thread tc = new Thread(this.consumers[i]);   tc.setName("Consumer-" + i);   tc.start();  } }
 public int checkProducerStatus() {  int s = NOT_START;  if (this.producer.getStatus() == RUNNING)   return RUNNING;  if (this.producer.getStatus() == STOPPED)   s = STOPPED;  return s; }
 public int checkConsumersStatus() {  int s = NOT_START;  for (int i = 0; i < NUM_THREAD; i++) {   if (this.consumers[i].getStatus() == RUNNING)    return RUNNING;   if (this.consumers[i].getStatus() == STOPPED)    s = STOPPED;  }  return s; }
 public int getProducerCount() {  return this.producer.getCount(); }
 public int getConsumersCount() {  int c = 0;  for (int i = 0; i < NUM_THREAD; i++)   c += this.consumers[i].getCount();  return c; }
 class DataPatchConsumer implements Runnable {
  DataPatch parent = null;  DataPatchConfig config = null;  int status = DataPatch.NOT_START;  int count = 0;  Transformer transformer = null;  Transformer pettifier = null;  Comparator<Element> comparator;
  public DataPatchConsumer(DataPatch dp, DataPatchConfig c) {   super();   this.parent = dp;   this.config = c;
   try {    if (this.config.getTransform() != null) {     TransformerFactory tFactory = TransformerFactory.newInstance();     StreamSource stylesource = new StreamSource(new File(this.config.getTransform()));     transformer = tFactory.newTransformer(stylesource);     transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");     transformer.setOutputProperty(OutputKeys.METHOD, "xml");     transformer.setOutputProperty(OutputKeys.INDENT, "no");     transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");     transformer.setErrorListener(new javax.xml.transform.ErrorListener() {      public void error(TransformerException exception) throws TransformerException {       throw (exception);      }
      public void fatalError(TransformerException exception) throws TransformerException {       throw (exception);      }
      public void warning(TransformerException exception) throws TransformerException {       throw (exception);      }     });    }   } catch (TransformerConfigurationException e) {    e.printStackTrace();   }   comparator = new Comparator<Element>() {    @Override    public int compare(Element o1, Element o2) {     // TODO for sorting T24 nodes by proprietary ordering     String name1 = o1.getNodeName();     String name2 = o2.getNodeName();     Integer i1 = new Integer(name1.substring(1, name1.length()));     Integer i2 = new Integer(name2.substring(1, name2.length()));     if (i1.compareTo(i2) == 0) {      String m_att1 = o1.getAttribute("m");      String m_att2 = o2.getAttribute("m");      Integer m1 = "".equals(m_att1) ? new Integer(0) : new Integer(m_att1);      Integer m2 = "".equals(m_att2) ? new Integer(0) : new Integer(m_att2);      if (m1.compareTo(m2) == 0) {       String s_att1 = o1.getAttribute("s");       String s_att2 = o2.getAttribute("s");       Integer s1 = "".equals(s_att1) ? new Integer(0) : new Integer(s_att1);       Integer s2 = "".equals(s_att2) ? new Integer(0) : new Integer(s_att2);       return s1.compareTo(s2);      } else       return m1.compareTo(m2);     } else      return i1.compareTo(i2);    }   };
  }
  public int getStatus() {   return status;  }
  public int getCount() {   return count;  }
  public void printDocument(Node doc, Result r) throws IOException, TransformerException {   if (pettifier == null) {    TransformerFactory tf = TransformerFactory.newInstance();    pettifier = tf.newTransformer();    pettifier.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");    pettifier.setOutputProperty(OutputKeys.METHOD, "xml");    pettifier.setOutputProperty(OutputKeys.INDENT, "no");    pettifier.setOutputProperty(OutputKeys.ENCODING, "UTF-8");   }   pettifier.transform(new DOMSource(doc), r);  }
  public void sortElements(Document doc) {      for(Node rootElement = doc.getDocumentElement();rootElement!=null; rootElement = rootElement.getNextSibling()) {    NodeList nl = rootElement.getChildNodes();    ArrayList<Element> array = new ArrayList<Element>();    for (int i = 0; i < nl.getLength(); i++) {     if (nl.item(i) instanceof Element) {      array.add((Element) nl.item(i));     }    }    Collections.sort(array, comparator);    // remove all exisiting elements    while (rootElement.hasChildNodes())     rootElement.removeChild(rootElement.getFirstChild());     // append sorted elements    for (Element n : array)     rootElement.appendChild(n);   }  }
  @Override  public void run() {   // TODO Logics for consumer to transform and output to target   try {    status = DataPatch.RUNNING;
    Connection conn = null;    PreparedStatement pstmt = null;
    if (config.getTargetType() == DataPatchConfig.TABLE) {     Date d1 = new Date();     System.out.println("Getting Connection");     conn = parent.getConnection();     conn.setAutoCommit(false);     Date d2 = new Date();     System.out.println("Connection Established (" + Math.abs(d2.getTime() - d1.getTime()) / 1000 + ")");     if (config.getTargetMode() == DataPatchConfig.UPDATE) {      pstmt = conn.prepareStatement(        "Update " + config.getTarget() + " SET XMLRECORD = ? WHERE RECID = ?");     } else if (config.getTargetMode() == DataPatchConfig.INSERT) {      pstmt = conn.prepareStatement(        "Insert Into " + config.getTarget() + "(XMLRECORD, RECID) VALUES (?,?)");     } else if (config.getTargetMode() == DataPatchConfig.MERGE) {      pstmt = conn.prepareStatement("Merge Into " + config.getTarget()        + " X Using (SELECT ? as XMLRECORD, ? as RECID FROM Dual) Y on (X.RECID = Y.RECID ) When Not Matched Then Insert(RECID, XMLRECORD) VALUES (Y.RECID, Y.XMLRECORD) When Matched Then Update set XMLRECORD = Y.XMLRECORD");     }    }    for (Document x = this.parent.getQueue().take(); !x.getDocumentElement().getNodeName().equals(      DataPatch.NO_MORE_WORK.getDocumentElement().getNodeName()); x = this.parent.getQueue().take()) {     // Apply XSLT of the xml document.     Document result = null;     if (this.transformer != null) {      DOMResult output = new DOMResult();      this.transformer.transform(new DOMSource(x), output);            result = (Document) output.getNode();      sortElements(result);      output = null;     } else {      result = x;     }     for (Element e = result.getDocumentElement(); e != null; e = (Element) e.getNextSibling()) {      StringWriter sw = new StringWriter();      printDocument(e, new StreamResult(sw));      if (config.getTargetType() == DataPatchConfig.TABLE) {       String recid = new String(e.getAttribute("id"));       try {        if (recid != null) {         pstmt.setString(1, sw.toString());         pstmt.setString(2, recid);         pstmt.executeUpdate();         conn.commit();        }       } catch (SQLException ex) {        System.err.println(sw.toString());        ex.printStackTrace();       }      } else if (config.getTargetType() == DataPatchConfig.FILE) {       synchronized (this.parent.getWriter()) {        this.parent.getWriter().write(sw.toString() + "\n");        this.parent.getWriter().flush();       }      }     }     result = null;     x = null;     count++;    }    if (conn != null) {     conn.commit();     conn.close();    }   } catch (SQLException | InterruptedException | TransformerException | IOException e) {    // TODO Auto-generated catch block    e.printStackTrace();   } finally {    status = DataPatch.STOPPED;   }
  }
 }
 public static void usage() {  System.out.println("Usage :");  System.out.println("        java DataPatch  [driver] [url] [username] [password] [config file] [thread_num?]");  System.out.println("");  System.out.println("where :");  System.out.println("        driver       = Driver");  System.out.println("        url          = Connection url");  System.out.println("        username     = Database username");  System.out.println("        password     = Database password");  System.out.println("        config file  = Configuration File");  System.out.println("        thread_num   = Number of consumer threads");  System.out.println(""); }
 public static void main(String args[]) {
  if (args.length != 6) {   usage();   System.exit(1);  }
  DefaultListableBeanFactory factory = new DefaultListableBeanFactory();  XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);  reader.loadBeanDefinitions(new FileSystemResource(args[4]));  TreeMap<String, DataPatchConfig> beans = new TreeMap<String, DataPatchConfig>(    factory.getBeansOfType(DataPatchConfig.class));
  DataPatch dp = new DataPatch(args[0], args[1], args[2], args[3], args[5]);  try {   for (Entry<String, DataPatchConfig> entry : beans.entrySet()) {    String key = entry.getKey();    DataPatchConfig c = entry.getValue();    System.out.println(key + " => " + c);    dp.initialize(c);    dp.process();    Date start_time = new Date();    int p_c1 = 0;    int p_c2 = 0;    while (dp.checkProducerStatus() != STOPPED || dp.checkConsumersStatus() != STOPPED) {     int c1 = dp.getProducerCount();     int c2 = dp.getConsumersCount();     if (!(c1 == 0 && c2 == 0))      System.out.println("Records inserted into queue = " + c1 + "(" + (c1 - p_c1)        + "); Records processed = " + c2 + "(" + (c2 - p_c2) + ")");     Thread.sleep(10000);     p_c1 = c1;     p_c2 = c2;    }    Date end_time = new Date();    System.out.println("Finished: " + (end_time.getTime() - start_time.getTime()) / 1000      + " seconds. Total record processed: " + dp.getConsumersCount());   }  } catch (InterruptedException e) {   // TODO Auto-generated catch block   e.printStackTrace();  }
 }
 class DataPatchProducer implements Runnable {
  DataPatch parent = null;  DataPatchConfig config = null;  int status = DataPatch.NOT_START;  int count = 0;
  public DataPatchProducer(DataPatch parent, DataPatchConfig config) {   super();   this.parent = parent;   this.config = config;  }
  public int getStatus() {   return status;  }
  public int getCount() {   return count;  }
  @Override  public void run() {   // TODO Auto-generated method stub   String r = "";   try {    status = DataPatch.RUNNING;    DocumentBuilderFactory fctr = DocumentBuilderFactory.newInstance();    DocumentBuilder bldr = fctr.newDocumentBuilder();    if (this.config.getSourceType() == DataPatchConfig.SQL) {     Date d1 = new Date();     System.out.println("Getting Connection");     Connection conn = parent.getConnection();
     Date d2 = new Date();     System.out.println("Connection Established (" + Math.abs(d2.getTime() - d1.getTime()) / 1000 + ")");     conn.setReadOnly(true);
     Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
     stmt.execute("SET TRANSACTION READ ONLY");     // stmt.setFetchSize(NUM_THREAD * 100);
     System.out.println("Executing SQL");     ResultSet rs = stmt.executeQuery(this.config.getSource());     System.out.println("Building List in progress ... ");
     while (rs.next()) {      r = "<result>";      for (int i = 1; i <= rs.getMetaData().getColumnCount(); i++) {       String name = rs.getMetaData().getColumnName(i);       String x = rs.getString(i);       r += "<" + name + ">" + x + "</" + name + ">";      }      r += "</result>";      InputSource insrc = new InputSource(new StringReader(r));      Document result = bldr.parse(insrc);      parent.getQueue().put(result);      insrc = null;      count++;     }     rs.close();     stmt.close();     conn.close();    } else if (this.config.getSourceType() == DataPatchConfig.FILE) {     FileReader fr = new FileReader(this.config.getSource());     BufferedReader br = new BufferedReader(fr);     for (String s; (s = br.readLine()) != null;) {      InputSource insrc = new InputSource(new StringReader(s));      Document result = bldr.parse(insrc);      parent.getQueue().put(result);      count++;
     }     br.close();     fr.close();    }   } catch (SQLException | InterruptedException | ParserConfigurationException | SAXException     | IOException e) {    // TODO Auto-generated catch block    System.out.println(r);    e.printStackTrace();   } finally {    status = DataPatch.STOPPED;    for (int j = 0; j < NUM_THREAD; j++)     try {      parent.getQueue().put(DataPatch.NO_MORE_WORK);     } catch (InterruptedException e) {      // TODO Auto-generated catch block      e.printStackTrace();     }   }
  }
 }
 class DataPatchItem implements Comparable<DataPatchItem> {
  String recid;  Document document;
  public String getRecid() {   return recid;  }
  public void setRecid(String recid) {   this.recid = recid;  }
  public Document getDocument() {   return document;  }
  public void setDocument(Document document) {   this.document = document;  }
  public String toString() {   return recid;  }
  @Override  public int compareTo(DataPatchItem paramT) {   // TODO Auto-generated method stub   return recid.compareTo(paramT.getRecid());  }
 }
}
